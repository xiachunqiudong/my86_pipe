# 五级流水Y86-64verilog实现

## 注意

- **`D_`表示源值，以表示信号来自于流水线寄存器D。**
- **`d_`表示结果值，表示信号在译码阶段产生。**

## fetch

![image-20221019223715303](C:\Users\xiadong\Desktop\my86_pipe\record\mk.assets\image-20221019223715303.png)

- 取指阶段需要选择当前需要的pc值，并预测下一阶段的pc值。
- 预测总是预测分支发生。
- 处理分支预测错误：当`M_icode==IJXX`并且`M_Cnd == 0`,从`M_valA`处取地址。
- 处理`ret`指令: 当`W_icode == IRET`,从`W_valM`处取地址。

## decode

- 从执行阶段前递过来

    `e_dstE = d_srcA/d_srcB` `e_valE`

- 从访存阶段前递过来

    `M_dsE = d_srcA/d_srcB ` `M_valE`

    `M_dsM = d_srcA/d_srcB ` `m_valM`

- 从写回阶段前递过来

    `W_dsE = d_srcA/d_srcB ` `W_valE`

    `W_dsM = d_srcA/d_srcB ` `W_valM`

## execute

## memory

## write back



## Y86流水线控制逻辑

![image-20221024230109641](C:\Users\xiadong\Desktop\my86_pipe\record\mk.assets\image-20221024230109641.png)

### 四种特殊情况

- 加载/使用冒险

    解决方法:在加载内存数据和使用该数据之间暂停一个时钟周期。

    只有mrmovq和popq指令才需要从内存中读取数据。当加载指令处于执行阶段并且使用指令处于译码阶段时候，将使用指令停止在译码阶段，并在下一个时钟周期往执行阶段中插入一个气泡。

    保持流水线寄存器F和D的状态，并往执行阶段插入气泡。

- 分支预测错误

    取消掉预测错误的指令，并且跳转到正确指令处

- ret指令

    流水线必须暂停到ret指令到达写回阶段。

    只有到达写回阶段的时候才从内存中读出数据并放入了`W_valM`,这个时候下一条指令的取指阶段可以将这个值作为要取指令的地址。

    流水线需要暂停三个时钟周期直到ret指令经过访存阶段读出返回地址。

- 异常

    禁止后面指令更新程序员可见状态，并且当发生异常的指令到达写回阶段停止执行

### 特殊情况的组合

![image-20221025103207827](C:\Users\xiadong\Desktop\my86_pipe\record\mk.assets\image-20221025103207827.png)

- 加载/使用冒险: 执行阶段为加载指令`mrmovq`和`popq`,译码阶段以`E_dstM`为源寄存器。
- 预测错误分支: 执行阶段为`JXX`指令
- ret: 译码，执行， 访存

可以看出`加载/使用`和`预测错误`不可能同时发生。

组合A:执行阶段中有一条不选择分支的跳转指令，译码阶段存在一条`ret`指令

组合A与分支预测错误情况类似，不同的是需要暂停取指时钟寄存器，不过到达下一个时钟周期，会选择`M_valA`作为地址取指令。此时流水线寄存器发生什么事情是无所谓的，流水线可以正确的处理这种情况。

组合B:加载指令设置寄存器`%rsp`, `ret`指令使用这个寄存器作为源操作数, 因为它必须从栈中弹出返回地址，流水线控制逻辑需要将`ret`指令阻塞在译码阶段。

# 测试

```markdown
irmovq r10 4
30 fa 00 00 00 00 00 00 00 00 04
rmmovq (7)rax r10
40 a0 00 00 00 00 00 00 00 07
mrmovq (7)rax r11
50 b0 00 00 00 00 00 00 00 07
add r10 r11
60 ab
```

# 





# 手把手教你设计处理器

流水线可以看成是用面积换性能，空间换时间。

流水线深度越深越好吗:

1. 流水线级数越多，每一级的硬件逻辑越少就，就可以得到更高的主频。
2. 流水线级数越多，寄存器也就更多，逻辑也会更复杂。
3. 分支预测失败需要冲刷流水线，级数越多损失就越大。



### 取指 IF

以最快的速度从存储器中取出指令供cpu执行，重点在于快和连续

快：

- ITCM

    配置小容量的存储器专门用于存储指令

- I-Cache

    指令缓存，利用软件的空间/时间局部性

连续不断:

- SRAM(32位)一个时钟周期只能读出一个(地址与32位对齐)的32位数据

- 对于分支指令，采用分支预测技术

    - 预测是否跳转

        预测方向

        1. 静态预测

            不依赖于任何执行过的指令信息和历史信息进行预测，仅依赖于指令本身进行预测

            最简单的预测方法就是预测总是跳转

            向后跳转的预测总是跳(跳转地址比当前地址小)

            向前跳转的预测总是不跳

        2. 动态预测

            根据已经执行过指令的历史信息和分支指令本身的信息进行方向预测

            2bit饱和计数器

            - 一级预测器
            - 二级预测器

    - 预测跳转地址





